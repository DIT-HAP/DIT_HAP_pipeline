---
title: "GO Terms Ridge Plot Analysis"
author: "Analysis Report"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 12,
  fig.height = 8,
  dpi = 300
)
```

## 加载必要的包

```{r load_packages}
# 安装并加载必要的包
required_packages <- c("readxl", "dplyr", "ggplot2", "ggridges", 
                       "tidyr", "patchwork", "RColorBrewer", "scales", "kableExtra", "stringr")

for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
}
```

## 读取和处理数据

```{r read_data}
# 读取 Excel 文件
go_data <- read_excel("results/HD_DIT_HAP/21_similarity_analysis_for_terms/GO_curve_features_for_terms_with_high_similarity_with_phenotype.xlsx")

# 显示数据结构
glimpse(go_data)
head(go_data)
```

```{r process_data}
# 处理数据，将features列展开为长格式
# 检查必要的列是否存在
required_cols <- c("feature_name", "features")
if (!all(required_cols %in% colnames(go_data))) {
  # 如果列名不同，请根据实际情况调整
  cat("请检查数据列名。当前列名:\n")
  print(colnames(go_data))
  cat("\n需要的列名: feature_name, features (以及 GO_name, GO_namespace 等)\n")
}

# 数据清洗和预处理
go_processed <- go_data %>%
  # 确保 feature_name 只包含 A, um, lam
  filter(feature_name %in% c("A", "um", "lam")) %>%
  # 移除缺失值
  drop_na(features) %>%
  # 如果没有 GO_namespace 列，创建一个默认的
  {
    if (!"GO_namespace" %in% colnames(.)) {
      mutate(., GO_namespace = "Unknown")
    } else {
      .
    }
  } %>%
  # 如果没有 GO_term 列，使用 GO_name 作为标识
  {
    if (!"GO_term" %in% colnames(.)) {
      mutate(., GO_term = GO_name)
    } else {
      .
    }
  } %>%
  # 确保 GO_name 列存在
  {
    if (!"GO_name" %in% colnames(.)) {
      mutate(., GO_name = GO_term)
    } else {
      .
    }
  }

# 显示处理后的数据摘要
cat("处理后的数据结构:\n")
glimpse(go_processed)
cat("\nFeature_name 的唯一值:\n")
print(unique(go_processed$feature_name))
cat("\nNamespace 的唯一值:\n")
print(unique(go_processed$GO_namespace))
```

## 展开 features 列并按 feature 均值排序

```{r expand_features}
# 展开 features 列，将逗号分隔的值转换为多行数据
go_expanded <- go_processed %>%
  mutate(
    # 将 features 列按逗号分割
    features_list = str_split(features, ",")
  ) %>%
  # 展开为长格式
  unnest(features_list) %>%
  # 清理和转换数据类型
  mutate(
    feature_value = as.numeric(str_trim(features_list))
  ) %>%
  # 移除缺失值
  drop_na(feature_value) %>%
  # 移除不需要的列
  select(-features_list, -features)

# 计算每个 term 的 feature 均值用于排序
term_means <- go_expanded %>%
  group_by(GO_name, GO_namespace, feature_name) %>%
  summarise(
    mean_value = mean(feature_value, na.rm = TRUE),
    n_genes = n(),
    .groups = "drop"
  )

# 为每个 namespace 和 feature 组合创建 term 的排序
term_order <- term_means %>%
  group_by(GO_namespace, feature_name) %>%
  arrange(desc(mean_value)) %>%
  mutate(
    order_rank = row_number()
  ) %>%
  ungroup()

# 将排序信息加入展开的数据
go_long <- go_expanded %>%
  left_join(term_order %>% select(GO_name, GO_namespace, feature_name, order_rank), 
            by = c("GO_name", "GO_namespace", "feature_name")) %>%
  group_by(GO_namespace, feature_name) %>%
  mutate(
    GO_name_ordered = factor(GO_name, levels = unique(GO_name[order(order_rank)]))
  ) %>%
  ungroup()

# 显示处理后的数据
cat("展开后的数据结构:\n")
glimpse(go_long)
cat("\n每个 term 的基因数量统计:\n")
print(term_means %>% select(GO_name, GO_namespace, feature_name, n_genes) %>% head(10))
```

## 创建山脊图函数

```{r ridge_plot_function}
create_ridge_plot <- function(data, namespace_filter, feature_name) {
  # 过滤数据
  filtered_data <- data %>%
    filter(GO_namespace == namespace_filter, feature_name == !!feature_name)
  
  if (nrow(filtered_data) == 0) {
    # 如果没有数据，返回空图
    return(ggplot() + 
           labs(title = paste("Ridge Plot:", feature_name, "in", namespace_filter, "(No Data)")) +
           theme_minimal())
  }
  
  # 创建山脊图
  p <- ggplot(filtered_data, aes(x = feature_value, y = GO_name_ordered, fill = GO_name_ordered)) +
    geom_density_ridges(
      scale = 0.9,
      alpha = 0.7,
      show.legend = FALSE,
      bandwidth = NULL  # 让 ggridges 自动选择带宽
    ) +
    labs(
      title = paste("Ridge Plot:", feature_name, "in", namespace_filter),
      x = paste("Feature Value:", feature_name),
      y = "GO Terms"
    ) +
    theme_ridges(
      grid = FALSE,
      center_axis_labels = TRUE
    ) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text.y = element_text(size = 8),
      axis.text.x = element_text(size = 10)
    ) +
    scale_fill_viridis_d(option = "plasma", alpha = 0.8)
  
  return(p)
}
```

## 为每个 Namespace 创建山脊图

```{r create_plots}
# 获取所有 namespace 和 feature
namespaces <- unique(go_long$GO_namespace)
features <- c("A", "um", "lam")

# 为每个 namespace 创建图表
plot_list <- list()

for (ns in namespaces) {
  cat("Processing namespace:", ns, "\n")
  
  # 为每个 feature 创建子图
  feature_plots <- list()
  
  for (feat in features) {
    feature_plots[[feat]] <- create_ridge_plot(go_long, ns, feat)
  }
  
  # 使用 patchwork 组合三个 feature 的图
  combined_plot <- feature_plots[["A"]] | feature_plots[["um"]] | feature_plots[["lam"]]
  
  plot_list[[ns]] <- combined_plot
}
```

## 显示图表

```{r display_plots, fig.height=10, fig.width=15}
# 显示每个 namespace 的图表
for (ns in names(plot_list)) {
  cat("\n### Namespace:", ns, "\n")
  print(plot_list[[ns]])
  cat("\n")
}
# 保存图表为 PDF
pdf_output_dir <- "results/HD_DIT_HAP/21_similarity_analysis_for_terms/plots"
if (!dir.exists(pdf_output_dir)) {
  dir.create(pdf_output_dir, recursive = TRUE)
}

# 保存每个 namespace 的图表为单独的 PDF 文件
for (ns in names(plot_list)) {
  # 清理文件名中的特殊字符
  clean_ns <- gsub("[^A-Za-z0-9_-]", "_", ns)
  pdf_filename <- file.path(pdf_output_dir, paste0("ridge_plot_", clean_ns, ".pdf"))
  
  ggsave(
    filename = pdf_filename,
    plot = plot_list[[ns]],
    width = 20,
    height = 10,
    units = "in",
    dpi = 300
  )
  
  cat("Saved:", pdf_filename, "\n")
}

# 保存汇总的所有图表到一个 PDF 文件
all_plots_pdf <- file.path(pdf_output_dir, "all_ridge_plots.pdf")
pdf(all_plots_pdf, width = 20, height = 10)
for (ns in names(plot_list)) {
  print(plot_list[[ns]])
}
dev.off()

cat("All plots saved to:", all_plots_pdf, "\n")

```

## 创建汇总统计表

```{r summary_stats}
# 创建汇总统计表
summary_stats <- go_long %>%
  group_by(GO_namespace, feature_name) %>%
  summarise(
    n_terms = n_distinct(GO_name),
    n_observations = n(),
    mean_value = mean(feature_value, na.rm = TRUE),
    sd_value = sd(feature_value, na.rm = TRUE),
    min_value = min(feature_value, na.rm = TRUE),
    max_value = max(feature_value, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(across(where(is.numeric), round, 3))

knitr::kable(summary_stats, 
             caption = "Summary Statistics by Namespace and Feature",
             format = "html") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
```

## 特征分布比较

```{r feature_comparison, fig.height=8, fig.width=12}
# 创建特征分布比较图
comparison_plot <- go_long %>%
  ggplot(aes(x = feature_value, fill = feature_name)) +
  geom_density(alpha = 0.7) +
  facet_wrap(~ GO_namespace, scales = "free") +
  labs(
    title = "Feature Distribution Comparison Across Namespaces",
    x = "Feature Value",
    y = "Density",
    fill = "Feature"
  ) +
  theme_minimal() +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_text(size = 12, face = "bold")
  )

# save the plot
ggsave(
  filename = "results/HD_DIT_HAP/21_similarity_analysis_for_terms/plots/feature_comparison.pdf",
  plot = comparison_plot,
  width = 12,
  height = 8
)
```

## 每个 Feature 的箱线图

```{r boxplot_comparison, fig.height=8, fig.width=12}
# 创建箱线图比较
boxplot_comparison <- go_long %>%
  ggplot(aes(x = feature_name, y = feature_value, fill = feature_name)) +
  geom_boxplot(alpha = 0.7) +
  facet_wrap(~ GO_namespace, scales = "free_y") +
  labs(
    title = "Feature Value Distribution by Namespace",
    x = "Feature Name",
    y = "Feature Value",
    fill = "Feature"
  ) +
  theme_minimal() +
  scale_fill_brewer(type = "qual", palette = "Set2") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# save the plot
ggsave(
  filename = "results/HD_DIT_HAP/21_similarity_analysis_for_terms/plots/boxplot_comparison.pdf",
  plot = boxplot_comparison,
  width = 12,
  height = 8
)
```

## 相关性分析

```{r correlation_analysis}
# 使用计算好的 term 均值进行相关性分析
correlation_data <- term_means %>%
  select(GO_name, GO_namespace, feature_name, mean_value) %>%
  pivot_wider(
    names_from = feature_name,
    values_from = mean_value,
    names_prefix = "feature_"
  ) %>%
  select(starts_with("feature_"))

# 计算相关性矩阵
if (ncol(correlation_data) >= 2) {
  correlation_matrix <- correlation_data %>%
    cor(use = "complete.obs")
  
  # 显示相关性矩阵
  knitr::kable(correlation_matrix, 
               caption = "Correlation Matrix of Features",
               format = "html") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
  
  # 创建相关性热图
  correlation_df <- expand.grid(
    Feature1 = rownames(correlation_matrix),
    Feature2 = colnames(correlation_matrix)
  ) %>%
    mutate(
      Correlation = as.vector(correlation_matrix)
    )
  
  correlation_plot <- ggplot(correlation_df, aes(x = Feature1, y = Feature2, fill = Correlation)) +
    geom_tile() +
    geom_text(aes(label = round(Correlation, 3)), color = "white", size = 4) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
    labs(
      title = "Feature Correlation Heatmap",
      x = "Feature 1",
      y = "Feature 2"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  print(correlation_plot)
} else {
  cat("Not enough features for correlation analysis\n")
}
```

## 数据导出

```{r export_data}
# 导出展开后的数据
write.csv(go_long, "results/expanded_go_data.csv", row.names = FALSE)

# 导出汇总统计
write.csv(summary_stats, "results/go_summary_stats.csv", row.names = FALSE)

# 导出 term 均值数据
write.csv(term_means, "results/go_term_means.csv", row.names = FALSE)

cat("数据已导出到 results/ 目录\n")
```

## 会话信息

```{r session_info}
sessionInfo()
```

---

**注意事项：**

1. 数据应该包含以下列：
   - `feature_name`: 包含 A, um, lam 值
   - `features`: 每个 term 里面所有基因的 feature 值，用逗号分隔
   - `GO_name`: GO term 名称
   - `GO_namespace`: GO namespace
   - `GO_term`: (可选) GO term ID

2. 如果列名不同，请在 `process_data` 部分调整相应的列名引用

3. 脚本会自动处理缺失的 GO_namespace 或 GO_term 列

4. 山脊图按每个 feature 的均值降序排列

5. 脚本会自动展开 `features` 列中的逗号分隔值，为每个基因创建一行数据

6. 这样每个 term 就有多个数据点，可以绘制出真正的山脊图密度曲线

7. 如果数据量很大，密度估计可能需要更长时间
